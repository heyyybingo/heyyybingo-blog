---
title: 事件循环
date: 2022-09-11 21:00:00
categories:
  - js基础
tags:
  - 浏览器
  - 事件循环
---

# 浏览器

## 宏任务与微任务

宏任务

- script(整体代码)
- setTimeout
- setInterval
- setImmediate
- I/O
- UI render

微任务

- process.nextTick
- Promise
- Async/Await(实际就是 promise)
- MutationObserver(html5 新特性)

## async/await 执行顺序

我们知道 async 隐式返回 Promise 作为结果的函数,那么可以简单理解为，await 后面的函数执行完毕时，await 会产生一个微任务(Promise.then 是微任务)。但是我们要注意这个微任务产生的时机，它是执行完 await 之后，直接跳出 async 函数，执行其他代码(此处就是协程的运作，A 暂停执行，控制权交给 B)。其他代码执行完毕后，再回到 async 函数去执行剩下的代码，然后把 await 后面的代码注册到微任务队列当中

## 执行步骤

- 从 宏任务 队列（例如 “script”）中出队（dequeue）并执行最早的任务。
- 执行所有 微任务：
- 当微任务队列非空时：
- 出队（dequeue）并执行最早的微任务。
- 如果有变更，则将变更渲染出来。
- 如果宏任务队列为空，则休眠直到出现宏任务。
- 转到步骤 1。

# node

事件循环是 Node.js 处理非阻塞 I/O 操作的机制——尽管 JavaScript 是单线程处理的——当有可能的时候，它们会把操作转移到系统内核中去。

因为目前大多数内核都是多线程的，所以它们可以在后台处理多种操作。当其中的一个操作完成的时候，内核通知 Node.js 将适合的回调函数添加到 轮询 队列中等待时机执行。

## 阶段

- 定时器：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。
- 待定回调：执行延迟到下一个循环迭代的 I/O 回调。
- idle, prepare：仅系统内部使用。
- 轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。
- 检测：setImmediate() 回调函数在这里执行。
- 关闭的回调函数：一些关闭的回调函数，如：socket.on('close', ...)

## 轮询

轮询 阶段有两个重要的功能：

- 计算应该阻塞和轮询 I/O 的时间。
- 然后，处理 轮询 队列里的事件。
  当事件循环进入 轮询 阶段且 没有被调度的计时器时 ，将发生以下两种情况之一：

如果 轮询 队列 不是空的 ，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制。

如果 轮询 队列 是空的 ，还有两件事发生：

如果脚本被 setImmediate() 调度，则事件循环将结束 轮询 阶段，并继续 检查 阶段以执行那些被调度的脚本。

如果脚本 未被 setImmediate()调度，则事件循环将等待回调被添加到队列中，然后立即执行。

一旦 轮询 队列为空，事件循环将检查 _已达到时间阈值的计时器_。如果一个或多个计时器已准备就绪，则事件循环将绕回计时器阶段以执行这些计时器的回调。

## setImmediate() 对比 setTimeout()

setImmediate() 和 setTimeout() 很类似，但是基于被调用的时机，他们也有不同表现。

- setImmediate() 设计为一旦在当前 轮询 阶段完成， 就执行脚本。
- setTimeout() 在最小阈值（ms 单位）过后运行脚本。

## process.nextTick

- process.nextTick() 从技术上讲不是事件循环的一部分
- 在事件循环继续之前下个阶段允许开发者处理错误，清理所有不必要的资源，或者重新尝试请求。
- 有时需要让回调在事件循环继续下个阶段之前运行 (At times it's necessary to allow a callback to run after the call stack has unwound but before the event loop continues.)。

function val(){

}
